<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Games202-lecture3-实时阴影和PCSS介绍</title>
    <url>/2025/01/20/Games202-Lecture3/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image1.png"
                      class=""
                >

<hr>
<h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><h3 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image2.png"
                      class=""
                >

<hr>
<h3 id="Pass1-从光源渲染一个深度"><a href="#Pass1-从光源渲染一个深度" class="headerlink" title="Pass1: 从光源渲染一个深度"></a>Pass1: 从光源渲染一个深度</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image3.png"
                      class=""
                >

<hr>
<h3 id="Pass2-从相机渲染，然后把渲染点投影到Shadow-Map比较深度"><a href="#Pass2-从相机渲染，然后把渲染点投影到Shadow-Map比较深度" class="headerlink" title="Pass2: 从相机渲染，然后把渲染点投影到Shadow Map比较深度"></a>Pass2: 从相机渲染，然后把渲染点投影到Shadow Map比较深度</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image4.png"
                      class=""
                >

<hr>
<h2 id="Shadow-Mapping的一些问题"><a href="#Shadow-Mapping的一些问题" class="headerlink" title="Shadow Mapping的一些问题"></a>Shadow Mapping的一些问题</h2><h3 id="自遮挡问题"><a href="#自遮挡问题" class="headerlink" title="自遮挡问题"></a>自遮挡问题</h3><p>相机相当于把地面离散化为垂直于相机的小块，相机越平行于地面越严重。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image5.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image6.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image7.png"
                      class=""
                >
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image8.png"
                      class=""
                >

<hr>
<h3 id="走样的问题：锯齿"><a href="#走样的问题：锯齿" class="headerlink" title="走样的问题：锯齿"></a>走样的问题：锯齿</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image9.png"
                      class=""
                >

<hr>
<h2 id="Shadow-Mapping中的数学：从渲染方程解释"><a href="#Shadow-Mapping中的数学：从渲染方程解释" class="headerlink" title="Shadow Mapping中的数学：从渲染方程解释"></a>Shadow Mapping中的数学：从渲染方程解释</h2><h3 id="不等式"><a href="#不等式" class="headerlink" title="不等式"></a>不等式</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image10.png"
                      class=""
                >

<hr>
<h3 id="实时渲染把不等式看作是约等式"><a href="#实时渲染把不等式看作是约等式" class="headerlink" title="实时渲染把不等式看作是约等式"></a>实时渲染把不等式看作是约等式</h3><p>一个重要的约等式（SplitSum和RSM都有用到）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image11.png"
                      class=""
                >

<hr>
<h3 id="Rendering-Equation上可以把V项给拆出来"><a href="#Rendering-Equation上可以把V项给拆出来" class="headerlink" title="Rendering Equation上可以把V项给拆出来"></a>Rendering Equation上可以把V项给拆出来</h3><p>相当于先做Shading，再乘以一个Shadow因子。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image12.png"
                      class=""
                >

<hr>
<h3 id="什么情况下拆分是比较准的"><a href="#什么情况下拆分是比较准的" class="headerlink" title="什么情况下拆分是比较准的"></a>什么情况下拆分是比较准的</h3><p>基本上就是Glossy BRDF下的面光源不准。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image13.png"
                      class=""
                >

<hr>
<h2 id="Percentage-Closer-Soft-Shadows-PCSS"><a href="#Percentage-Closer-Soft-Shadows-PCSS" class="headerlink" title="Percentage Closer Soft Shadows (PCSS)"></a>Percentage Closer Soft Shadows (PCSS)</h2><h3 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage Closer Filtering (PCF)"></a>Percentage Closer Filtering (PCF)</h3><p>最开始就是做抗锯齿的。</p>
<p><strong>做法</strong>：在Shadow Map上对应点附近7x7比较深度后再做平均值（所有结果都是0或者1的）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image14.png"
                      class=""
                >

<p><strong>效果</strong>：没有锯齿，还有类似软阴影的效果。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image15.png"
                      class=""
                >

<hr>
<h3 id="PCSS分析"><a href="#PCSS分析" class="headerlink" title="PCSS分析"></a>PCSS分析</h3><p>发现：软阴影和硬阴影是跟笔尖和纸的距离有关。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image16.png"
                      class=""
                >

<hr>
<h3 id="PCSS分析：不同遮挡物距离需要的Filter核的大小关系"><a href="#PCSS分析：不同遮挡物距离需要的Filter核的大小关系" class="headerlink" title="PCSS分析：不同遮挡物距离需要的Filter核的大小关系"></a>PCSS分析：不同遮挡物距离需要的Filter核的大小关系</h3><p>貌似我们找的depth应该是黄色的那个线，而不应该是蓝绿线。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image17.png"
                      class=""
                >

<hr>
<h3 id="PCSS算法"><a href="#PCSS算法" class="headerlink" title="PCSS算法"></a>PCSS算法</h3><ol>
<li>第一步是通过ShadowMap计算遮挡物的平均深度（遮挡物的判断需要用深度比较一下）。</li>
<li>第二步计算Filter Size。</li>
<li>第三步就是PCF（面光源的ShadowMap是由面光源的中心生成的）。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image18.png"
                      class=""
                >

<hr>
<h3 id="PCSS算法：解释如何第一步找Blocker平均Depth大小"><a href="#PCSS算法：解释如何第一步找Blocker平均Depth大小" class="headerlink" title="PCSS算法：解释如何第一步找Blocker平均Depth大小"></a>PCSS算法：解释如何第一步找Blocker平均Depth大小</h3><p>这个是启发式的（用ShadingPoint往面光源连线，取相交于ShadowMap的区域来计算遮挡物的平均深度）；另外还可以用固定的5x5大小来找。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/20/Games202-Lecture3/image19.png"
                      class=""
                >]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture12-实时光线追踪1</title>
    <url>/2025/01/29/Games202-lecture12/</url>
    <content><![CDATA[<h2 id="最后一节课会讲一下Nanite和Lumen？"><a href="#最后一节课会讲一下Nanite和Lumen？" class="headerlink" title="最后一节课会讲一下Nanite和Lumen？"></a>最后一节课会讲一下Nanite和Lumen？</h2><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image1.png"
                      class=""
                >

<h2 id="Real-Time-Ray-Tracing：1spp的Path-Tracing"><a href="#Real-Time-Ray-Tracing：1spp的Path-Tracing" class="headerlink" title="Real Time Ray Tracing：1spp的Path Tracing"></a>Real Time Ray Tracing：1spp的Path Tracing</h2><h3 id="RTRT核心技术是降噪："><a href="#RTRT核心技术是降噪：" class="headerlink" title="RTRT核心技术是降噪："></a>RTRT核心技术是降噪：</h3><h4 id="需要实时的Filter（"><a href="#需要实时的Filter（" class="headerlink" title="需要实时的Filter（&lt;2ms）"></a>需要实时的Filter（&lt;2ms）</h4><h4 id="工业界的解决方案是Temporal，时间连续性"><a href="#工业界的解决方案是Temporal，时间连续性" class="headerlink" title="工业界的解决方案是Temporal，时间连续性"></a>工业界的解决方案是Temporal，时间连续性</h4><h4 id="需要用Motion-Vectors找到上一帧对应的像素点在哪里，用上一帧结果复用"><a href="#需要用Motion-Vectors找到上一帧对应的像素点在哪里，用上一帧结果复用" class="headerlink" title="需要用Motion Vectors找到上一帧对应的像素点在哪里，用上一帧结果复用"></a>需要用Motion Vectors找到上一帧对应的像素点在哪里，用上一帧结果复用</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image2.png"
                      class=""
                >

<h3 id="Motion-Vector计算方法（按道理来说大部分静态物体只需要用两帧的View矩阵就可以得到Motion-Vector了吧）"><a href="#Motion-Vector计算方法（按道理来说大部分静态物体只需要用两帧的View矩阵就可以得到Motion-Vector了吧）" class="headerlink" title="Motion Vector计算方法（按道理来说大部分静态物体只需要用两帧的View矩阵就可以得到Motion Vector了吧）"></a>Motion Vector计算方法（按道理来说大部分静态物体只需要用两帧的View矩阵就可以得到Motion Vector了吧）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image3.png"
                      class=""
                >

<h3 id="当前帧用Filter去过滤，然后应用上一帧的值平均一下"><a href="#当前帧用Filter去过滤，然后应用上一帧的值平均一下" class="headerlink" title="当前帧用Filter去过滤，然后应用上一帧的值平均一下"></a>当前帧用Filter去过滤，然后应用上一帧的值平均一下</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image4.png"
                      class=""
                >

<h3 id="时域降噪失败的情况（切换场景、倒退走（或者转镜头吧）、被遮挡）"><a href="#时域降噪失败的情况（切换场景、倒退走（或者转镜头吧）、被遮挡）" class="headerlink" title="时域降噪失败的情况（切换场景、倒退走（或者转镜头吧）、被遮挡）"></a>时域降噪失败的情况（切换场景、倒退走（或者转镜头吧）、被遮挡）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image5.png"
                      class=""
                >

<h3 id="解决鬼影问题"><a href="#解决鬼影问题" class="headerlink" title="解决鬼影问题"></a>解决鬼影问题</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/29/Games202-lecture12/image6.png"
                      class=""
                >

<h3 id="时域降噪另一个问题Shading问题：场景物体没有动，但是光照修改后Shading变化了；或者比如镜子没有动，但是反射到镜子的物体动了"><a href="#时域降噪另一个问题Shading问题：场景物体没有动，但是光照修改后Shading变化了；或者比如镜子没有动，但是反射到镜子的物体动了" class="headerlink" title="时域降噪另一个问题Shading问题：场景物体没有动，但是光照修改后Shading变化了；或者比如镜子没有动，但是反射到镜子的物体动了"></a>时域降噪另一个问题Shading问题：场景物体没有动，但是光照修改后Shading变化了；或者比如镜子没有动，但是反射到镜子的物体动了</h3><h3 id="时域降噪也可以用来做抗锯齿-TAA"><a href="#时域降噪也可以用来做抗锯齿-TAA" class="headerlink" title="时域降噪也可以用来做抗锯齿-TAA"></a>时域降噪也可以用来做抗锯齿-TAA</h3>]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Filtering</tag>
        <tag>Denoising</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture13-实时光线追踪2</title>
    <url>/2025/01/30/Games202-lecture13/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image1.png"
                      class=""
                >

<h2 id="低通滤波的大致做法（高斯核考虑大概3σ范围就行了）"><a href="#低通滤波的大致做法（高斯核考虑大概3σ范围就行了）" class="headerlink" title="低通滤波的大致做法（高斯核考虑大概3σ范围就行了）"></a>低通滤波的大致做法（高斯核考虑大概3σ范围就行了）</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image2.png"
                      class=""
                >

<h2 id="双边滤波（Bilateral-filtering）"><a href="#双边滤波（Bilateral-filtering）" class="headerlink" title="双边滤波（Bilateral filtering）"></a>双边滤波（Bilateral filtering）</h2><h3 id="高斯滤波边缘的地方会被模糊，因为边界也是高频信号"><a href="#高斯滤波边缘的地方会被模糊，因为边界也是高频信号" class="headerlink" title="高斯滤波边缘的地方会被模糊，因为边界也是高频信号"></a>高斯滤波边缘的地方会被模糊，因为边界也是高频信号</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image3.png"
                      class=""
                >

<h3 id="双边滤波的思路和算法（公式相当于是多个高斯函数相乘）"><a href="#双边滤波的思路和算法（公式相当于是多个高斯函数相乘）" class="headerlink" title="双边滤波的思路和算法（公式相当于是多个高斯函数相乘）"></a>双边滤波的思路和算法（公式相当于是多个高斯函数相乘）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image4.png"
                      class=""
                >

<h3 id="噪点和边界无法区分，导致噪声可能也会保留"><a href="#噪点和边界无法区分，导致噪声可能也会保留" class="headerlink" title="噪点和边界无法区分，导致噪声可能也会保留"></a>噪点和边界无法区分，导致噪声可能也会保留</h3><h2 id="联合双边滤波（Joint-Bilateral-filtering）"><a href="#联合双边滤波（Joint-Bilateral-filtering）" class="headerlink" title="联合双边滤波（Joint Bilateral filtering）"></a>联合双边滤波（Joint Bilateral filtering）</h2><h3 id="思路来源，把高斯滤波和双边滤波结合。距离和颜色两种指标"><a href="#思路来源，把高斯滤波和双边滤波结合。距离和颜色两种指标" class="headerlink" title="思路来源，把高斯滤波和双边滤波结合。距离和颜色两种指标"></a>思路来源，把高斯滤波和双边滤波结合。距离和颜色两种指标</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image5.png"
                      class=""
                >

<h3 id="不一定是高斯，只要随距离衰减就行"><a href="#不一定是高斯，只要随距离衰减就行" class="headerlink" title="不一定是高斯，只要随距离衰减就行"></a>不一定是高斯，只要随距离衰减就行</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image6.png"
                      class=""
                >

<h3 id="可以增加更多的标准来修改不同点的权重：深度、法线、颜色"><a href="#可以增加更多的标准来修改不同点的权重：深度、法线、颜色" class="headerlink" title="可以增加更多的标准来修改不同点的权重：深度、法线、颜色"></a>可以增加更多的标准来修改不同点的权重：深度、法线、颜色</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image7.png"
                      class=""
                >

<h3 id="缺点：需要多计算，而且核的权重必须实时计算"><a href="#缺点：需要多计算，而且核的权重必须实时计算" class="headerlink" title="缺点：需要多计算，而且核的权重必须实时计算"></a>缺点：需要多计算，而且核的权重必须实时计算</h3><h2 id="大的滤波核比如128x128怎么办，计算量太大"><a href="#大的滤波核比如128x128怎么办，计算量太大" class="headerlink" title="大的滤波核比如128x128怎么办，计算量太大"></a>大的滤波核比如128x128怎么办，计算量太大</h2><h3 id="高斯核滤波可以分离水平和垂直步骤减少计算量"><a href="#高斯核滤波可以分离水平和垂直步骤减少计算量" class="headerlink" title="高斯核滤波可以分离水平和垂直步骤减少计算量"></a>高斯核滤波可以分离水平和垂直步骤减少计算量</h3><h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image8.png"
                      class=""
                >

<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image9.png"
                      class=""
                >

<h3 id="渐进增加核的大小，多次滤波，但是每次滤波增加间隔2-i采集，图例没有画完"><a href="#渐进增加核的大小，多次滤波，但是每次滤波增加间隔2-i采集，图例没有画完" class="headerlink" title="渐进增加核的大小，多次滤波，但是每次滤波增加间隔2^i采集，图例没有画完"></a>渐进增加核的大小，多次滤波，但是每次滤波增加间隔2^i采集，图例没有画完</h3><h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image10.png"
                      class=""
                >

<h3 id="这样做的原理，这里从频域空间解释了为什么可以间隔采样（没看懂）。"><a href="#这样做的原理，这里从频域空间解释了为什么可以间隔采样（没看懂）。" class="headerlink" title="这样做的原理，这里从频域空间解释了为什么可以间隔采样（没看懂）。"></a>这样做的原理，这里从频域空间解释了为什么可以间隔采样（没看懂）。</h3><h4 id="不过我感觉是i-1时黑色的球和相邻的灰色球包含了一段相同信息，而间隔一个之后就完全没有相同信息了。然后采样三次相当于是5x5x5-125的滤波核，感觉应该用4x4x4就可以模拟64的滤波核了吧？"><a href="#不过我感觉是i-1时黑色的球和相邻的灰色球包含了一段相同信息，而间隔一个之后就完全没有相同信息了。然后采样三次相当于是5x5x5-125的滤波核，感觉应该用4x4x4就可以模拟64的滤波核了吧？" class="headerlink" title="不过我感觉是i&#x3D;1时黑色的球和相邻的灰色球包含了一段相同信息，而间隔一个之后就完全没有相同信息了。然后采样三次相当于是5x5x5&#x3D;125的滤波核，感觉应该用4x4x4就可以模拟64的滤波核了吧？"></a>不过我感觉是i&#x3D;1时黑色的球和相邻的灰色球包含了一段相同信息，而间隔一个之后就完全没有相同信息了。然后采样三次相当于是5x5x5&#x3D;125的滤波核，感觉应该用4x4x4就可以模拟64的滤波核了吧？</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image11.png"
                      class=""
                >

<h3 id="问题：联合双边滤波会留下高频信息，上面的图默认说是把高频全都去掉了才能成立"><a href="#问题：联合双边滤波会留下高频信息，上面的图默认说是把高频全都去掉了才能成立" class="headerlink" title="问题：联合双边滤波会留下高频信息，上面的图默认说是把高频全都去掉了才能成立"></a>问题：联合双边滤波会留下高频信息，上面的图默认说是把高频全都去掉了才能成立</h3><h2 id="滤波可以用到PCSS和SSR中等"><a href="#滤波可以用到PCSS和SSR中等" class="headerlink" title="滤波可以用到PCSS和SSR中等"></a>滤波可以用到PCSS和SSR中等</h2><h3 id="有一些很亮的点怎么解决（outlier-异常点）"><a href="#有一些很亮的点怎么解决（outlier-异常点）" class="headerlink" title="有一些很亮的点怎么解决（outlier 异常点）"></a>有一些很亮的点怎么解决（outlier 异常点）</h3><h4 id="计算整个画面的均值和方差，然后判断点是否为outlier，最后把Outlier给Clamp到正常值范围"><a href="#计算整个画面的均值和方差，然后判断点是否为outlier，最后把Outlier给Clamp到正常值范围" class="headerlink" title="计算整个画面的均值和方差，然后判断点是否为outlier，最后把Outlier给Clamp到正常值范围"></a>计算整个画面的均值和方差，然后判断点是否为outlier，最后把Outlier给Clamp到正常值范围</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/30/Games202-lecture13/image12.png"
                      class=""
                >

<h2 id="作业5是光线追踪，作业4是kulla-conty能量补全"><a href="#作业5是光线追踪，作业4是kulla-conty能量补全" class="headerlink" title="作业5是光线追踪，作业4是kulla conty能量补全"></a>作业5是光线追踪，作业4是kulla conty能量补全</h2>]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Filtering</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture14-实时光线追踪3</title>
    <url>/2025/01/31/Games202-lecture14/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image1.png"
                      class=""
                >

<h2 id="SVGF-时空方差引导滤波-（也是联合双边滤波的一种）"><a href="#SVGF-时空方差引导滤波-（也是联合双边滤波的一种）" class="headerlink" title="SVGF-时空方差引导滤波 （也是联合双边滤波的一种）"></a>SVGF-时空方差引导滤波 （也是联合双边滤波的一种）</h2><h3 id="Depth，这里考虑的是沿着法线方向的深度差异"><a href="#Depth，这里考虑的是沿着法线方向的深度差异" class="headerlink" title="Depth，这里考虑的是沿着法线方向的深度差异"></a>Depth，这里考虑的是沿着法线方向的深度差异</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image2.png"
                      class=""
                >

<h3 id="Normal，法线"><a href="#Normal，法线" class="headerlink" title="Normal，法线"></a>Normal，法线</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image3.png"
                      class=""
                >

<h3 id="Luminance，亮度-或者说是灰度值"><a href="#Luminance，亮度-或者说是灰度值" class="headerlink" title="Luminance，亮度 或者说是灰度值"></a>Luminance，亮度 或者说是灰度值</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image4.png"
                      class=""
                >

<h2 id="RAE-周期自动编码方法，神经网络实现，属于后期处理"><a href="#RAE-周期自动编码方法，神经网络实现，属于后期处理" class="headerlink" title="RAE-周期自动编码方法，神经网络实现，属于后期处理"></a>RAE-周期自动编码方法，神经网络实现，属于后期处理</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image5.png"
                      class=""
                >

<h2 id="抗锯齿方法"><a href="#抗锯齿方法" class="headerlink" title="抗锯齿方法"></a>抗锯齿方法</h2><h3 id="Temporal-Anti-Aliasing-TAA-，一个像素随机扰动采样点（一般是固定的几个点，可以在相机不动的情况下也能收敛）"><a href="#Temporal-Anti-Aliasing-TAA-，一个像素随机扰动采样点（一般是固定的几个点，可以在相机不动的情况下也能收敛）" class="headerlink" title="Temporal Anti-Aliasing(TAA)，一个像素随机扰动采样点（一般是固定的几个点，可以在相机不动的情况下也能收敛）"></a>Temporal Anti-Aliasing(TAA)，一个像素随机扰动采样点（一般是固定的几个点，可以在相机不动的情况下也能收敛）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image6.png"
                      class=""
                >

<h3 id="MSAA和SSAA：MSAA是一个像素点有比如4个感知点，然后不同的几何只会渲染一次，渲染的位置可能是对应感知点的中心；SSAA是真正的着色"><a href="#MSAA和SSAA：MSAA是一个像素点有比如4个感知点，然后不同的几何只会渲染一次，渲染的位置可能是对应感知点的中心；SSAA是真正的着色" class="headerlink" title="MSAA和SSAA：MSAA是一个像素点有比如4个感知点，然后不同的几何只会渲染一次，渲染的位置可能是对应感知点的中心；SSAA是真正的着色"></a>MSAA和SSAA：MSAA是一个像素点有比如4个感知点，然后不同的几何只会渲染一次，渲染的位置可能是对应感知点的中心；SSAA是真正的着色</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image7.png"
                      class=""
                >

<h3 id="基于图像的抗锯齿：SMAA（Enhanced-subpixel-morphologic-AA），主要还是需要找到边界"><a href="#基于图像的抗锯齿：SMAA（Enhanced-subpixel-morphologic-AA），主要还是需要找到边界" class="headerlink" title="基于图像的抗锯齿：SMAA（Enhanced subpixel morphologic AA），主要还是需要找到边界"></a>基于图像的抗锯齿：SMAA（Enhanced subpixel morphologic AA），主要还是需要找到边界</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image8.png"
                      class=""
                >

<h3 id="注意-G-buffers-不能做反走样！"><a href="#注意-G-buffers-不能做反走样！" class="headerlink" title="注意: G-buffers 不能做反走样！"></a>注意: G-buffers 不能做反走样！</h3><h2 id="Clustered-Shading"><a href="#Clustered-Shading" class="headerlink" title="Clustered Shading"></a>Clustered Shading</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image9.png"
                      class=""
                >

<h2 id="Nanite的主要思想就是选取LOD，只不过选取规则是UE5自己定的，而且效果很好"><a href="#Nanite的主要思想就是选取LOD，只不过选取规则是UE5自己定的，而且效果很好" class="headerlink" title="Nanite的主要思想就是选取LOD，只不过选取规则是UE5自己定的，而且效果很好"></a>Nanite的主要思想就是选取LOD，只不过选取规则是UE5自己定的，而且效果很好</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image10.png"
                      class=""
                >

<h3 id="一些用LOD的困难"><a href="#一些用LOD的困难" class="headerlink" title="一些用LOD的困难"></a>一些用LOD的困难</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image11.png"
                      class=""
                >

<h2 id="Lumen，全局光照"><a href="#Lumen，全局光照" class="headerlink" title="Lumen，全局光照"></a>Lumen，全局光照</h2><h3 id="可能有的技术"><a href="#可能有的技术" class="headerlink" title="可能有的技术"></a>可能有的技术</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image12.png"
                      class=""
                >

<h3 id="Lumen用到的解决方法"><a href="#Lumen用到的解决方法" class="headerlink" title="Lumen用到的解决方法"></a>Lumen用到的解决方法</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/31/Games202-lecture14/image13.png"
                      class=""
                >
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Filtering</tag>
        <tag>Denoising</tag>
        <tag>Anti-Aliasing</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture5-实时的环境光照1</title>
    <url>/2025/01/22/Games202-lecture5/</url>
    <content><![CDATA[<h2 id="Distance-Field-Soft-Shadows"><a href="#Distance-Field-Soft-Shadows" class="headerlink" title="Distance Field Soft Shadows"></a>Distance Field Soft Shadows</h2><h3 id="软阴影效果"><a href="#软阴影效果" class="headerlink" title="软阴影效果"></a>软阴影效果</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image1.png"
                      class=""
                >

<h3 id="Distance-Functions-定义空间一点到所有物体最近的距离"><a href="#Distance-Functions-定义空间一点到所有物体最近的距离" class="headerlink" title="Distance Functions: 定义空间一点到所有物体最近的距离"></a>Distance Functions: 定义空间一点到所有物体最近的距离</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image2.png"
                      class=""
                >

<h3 id="对于物体移动的情况下，SDF插值比图像插值得到的效果表示物体边界的效果更准确"><a href="#对于物体移动的情况下，SDF插值比图像插值得到的效果表示物体边界的效果更准确" class="headerlink" title="对于物体移动的情况下，SDF插值比图像插值得到的效果表示物体边界的效果更准确"></a>对于物体移动的情况下，SDF插值比图像插值得到的效果表示物体边界的效果更准确</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image3.png"
                      class=""
                >

<h3 id="SDF的作用1：用来做RayMarching步进。相当于空间一点可以走至少SDF的距离，这样可以走的快一点（如果sdf都很小咋办，比如一个很狭窄的过道那种？）"><a href="#SDF的作用1：用来做RayMarching步进。相当于空间一点可以走至少SDF的距离，这样可以走的快一点（如果sdf都很小咋办，比如一个很狭窄的过道那种？）" class="headerlink" title="SDF的作用1：用来做RayMarching步进。相当于空间一点可以走至少SDF的距离，这样可以走的快一点（如果sdf都很小咋办，比如一个很狭窄的过道那种？）"></a>SDF的作用1：用来做RayMarching步进。相当于空间一点可以走至少SDF的距离，这样可以走的快一点（如果sdf都很小咋办，比如一个很狭窄的过道那种？）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image4.png"
                      class=""
                >

<h3 id="SDF的作用2：用来做软阴影。相当于找到Shading-Point射线方向最小的SDF值，可以算出一个安全角度，如果角度越小，则越容易遮挡"><a href="#SDF的作用2：用来做软阴影。相当于找到Shading-Point射线方向最小的SDF值，可以算出一个安全角度，如果角度越小，则越容易遮挡" class="headerlink" title="SDF的作用2：用来做软阴影。相当于找到Shading Point射线方向最小的SDF值，可以算出一个安全角度，如果角度越小，则越容易遮挡"></a>SDF的作用2：用来做软阴影。相当于找到Shading Point射线方向最小的SDF值，可以算出一个安全角度，如果角度越小，则越容易遮挡</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image5.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image6.png"
                      class=""
                >

<h3 id="SDF的缺点：需要预计算，储存需要3维量大"><a href="#SDF的缺点：需要预计算，储存需要3维量大" class="headerlink" title="SDF的缺点：需要预计算，储存需要3维量大"></a>SDF的缺点：需要预计算，储存需要3维量大</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image7.png"
                      class=""
                >

<h2 id="环境光着色（Environment-Lighting），这里主要讨论的是镜面反射"><a href="#环境光着色（Environment-Lighting），这里主要讨论的是镜面反射" class="headerlink" title="环境光着色（Environment Lighting），这里主要讨论的是镜面反射"></a>环境光着色（Environment Lighting），这里主要讨论的是镜面反射</h2><h3 id="假设环境光无限远"><a href="#假设环境光无限远" class="headerlink" title="假设环境光无限远"></a>假设环境光无限远</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image8.png"
                      class=""
                >

<h3 id="思路，不考虑遮挡的情况（后面可能用AO来补偿一下）"><a href="#思路，不考虑遮挡的情况（后面可能用AO来补偿一下）" class="headerlink" title="思路，不考虑遮挡的情况（后面可能用AO来补偿一下）"></a>思路，不考虑遮挡的情况（后面可能用AO来补偿一下）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image9.png"
                      class=""
                >

<h3 id="近似拆分：黄框相当于是对环境光模糊，然后可以放到mipmap中；黄框右边就是对BRDF的Cos积分"><a href="#近似拆分：黄框相当于是对环境光模糊，然后可以放到mipmap中；黄框右边就是对BRDF的Cos积分" class="headerlink" title="近似拆分：黄框相当于是对环境光模糊，然后可以放到mipmap中；黄框右边就是对BRDF的Cos积分"></a>近似拆分：黄框相当于是对环境光模糊，然后可以放到mipmap中；黄框右边就是对BRDF的Cos积分</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image10.png"
                      class=""
                >

<h3 id="预计算BRDF项：红框部分"><a href="#预计算BRDF项：红框部分" class="headerlink" title="预计算BRDF项：红框部分"></a>预计算BRDF项：红框部分</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image11.png"
                      class=""
                >

<h3 id="微表面模型的BRDF分了菲涅尔项、几何遮挡、法线分布三部分"><a href="#微表面模型的BRDF分了菲涅尔项、几何遮挡、法线分布三部分" class="headerlink" title="微表面模型的BRDF分了菲涅尔项、几何遮挡、法线分布三部分"></a>微表面模型的BRDF分了菲涅尔项、几何遮挡、法线分布三部分</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image12.png"
                      class=""
                >

<h3 id="菲涅尔项和NDF项，（G项这里可能没有考虑）"><a href="#菲涅尔项和NDF项，（G项这里可能没有考虑）" class="headerlink" title="菲涅尔项和NDF项，（G项这里可能没有考虑）"></a>菲涅尔项和NDF项，（G项这里可能没有考虑）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image13.png"
                      class=""
                >

<h3 id="SplitSum来源：为了简化，把R0拆分处理来（R0貌似是直接用基色？貌似unity绝缘体直接用的0-04xBaseColor，导体是0-96xBaseColor）"><a href="#SplitSum来源：为了简化，把R0拆分处理来（R0貌似是直接用基色？貌似unity绝缘体直接用的0-04xBaseColor，导体是0-96xBaseColor）" class="headerlink" title="SplitSum来源：为了简化，把R0拆分处理来（R0貌似是直接用基色？貌似unity绝缘体直接用的0.04xBaseColor，导体是0.96xBaseColor）"></a>SplitSum来源：为了简化，把R0拆分处理来（R0貌似是直接用基色？貌似unity绝缘体直接用的0.04xBaseColor，导体是0.96xBaseColor）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/22/Games202-lecture5/image14.png"
                      class=""
                >

<h3 id="计算SplitSum的这两项是用蒙特卡洛采样预计算的"><a href="#计算SplitSum的这两项是用蒙特卡洛采样预计算的" class="headerlink" title="计算SplitSum的这两项是用蒙特卡洛采样预计算的"></a>计算SplitSum的这两项是用蒙特卡洛采样预计算的</h3>]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Shadow</tag>
        <tag>Soft Shadow</tag>
        <tag>PBR</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture4-实时阴影2</title>
    <url>/2025/01/21/Games202-lecture4/</url>
    <content><![CDATA[<h2 id="本节大纲"><a href="#本节大纲" class="headerlink" title="本节大纲"></a>本节大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image1.png"
                      class=""
                >

<h2 id="PCF和PCSS深入理解"><a href="#PCF和PCSS深入理解" class="headerlink" title="PCF和PCSS深入理解"></a>PCF和PCSS深入理解</h2><h3 id="PCF的数学原理：卷积（加权平均）"><a href="#PCF的数学原理：卷积（加权平均）" class="headerlink" title="PCF的数学原理：卷积（加权平均）"></a>PCF的数学原理：卷积（加权平均）</h3><p>PCSS本质是比较场景深度和深度图上周围像素比较，即PCF的工作，PCSS主要就是在深度图上周围像素这个size会变换。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image2.png"
                      class=""
                >

<h3 id="深度图上卷积再比较与深度比较后再卷积的区别"><a href="#深度图上卷积再比较与深度比较后再卷积的区别" class="headerlink" title="深度图上卷积再比较与深度比较后再卷积的区别"></a>深度图上卷积再比较与深度比较后再卷积的区别</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image3.png"
                      class=""
                >

<h3 id="回顾一下PCSS，主要是性能问题（第一步是求遮挡物的平均深度）"><a href="#回顾一下PCSS，主要是性能问题（第一步是求遮挡物的平均深度）" class="headerlink" title="回顾一下PCSS，主要是性能问题（第一步是求遮挡物的平均深度）"></a>回顾一下PCSS，主要是性能问题（第一步是求遮挡物的平均深度）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image4.png"
                      class=""
                >

<h2 id="Variance-Soft-Shadow-Mapping-VSSM"><a href="#Variance-Soft-Shadow-Mapping-VSSM" class="headerlink" title="Variance Soft Shadow Mapping (VSSM)"></a>Variance Soft Shadow Mapping (VSSM)</h2><h3 id="主要是加速PCSS的第一步和第三步"><a href="#主要是加速PCSS的第一步和第三步" class="headerlink" title="主要是加速PCSS的第一步和第三步"></a>主要是加速PCSS的第一步和第三步</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image5.png"
                      class=""
                >

<h3 id="先假设深度都是正态分布的，那么只需要通过方差和均值就可以近似求得当前像素的百分比"><a href="#先假设深度都是正态分布的，那么只需要通过方差和均值就可以近似求得当前像素的百分比" class="headerlink" title="先假设深度都是正态分布的，那么只需要通过方差和均值就可以近似求得当前像素的百分比"></a>先假设深度都是正态分布的，那么只需要通过方差和均值就可以近似求得当前像素的百分比</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image6.png"
                      class=""
                >

<h3 id="求深度在某一块的均值和方差可以通过深度和深度平方的图（一张图可以用rg储存）来求得"><a href="#求深度在某一块的均值和方差可以通过深度和深度平方的图（一张图可以用rg储存）来求得" class="headerlink" title="求深度在某一块的均值和方差可以通过深度和深度平方的图（一张图可以用rg储存）来求得"></a>求深度在某一块的均值和方差可以通过深度和深度平方的图（一张图可以用rg储存）来求得</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image7.png"
                      class=""
                >

<h3 id="求CDF需要打表，或者用c-解析解的函数求得"><a href="#求CDF需要打表，或者用c-解析解的函数求得" class="headerlink" title="求CDF需要打表，或者用c++解析解的函数求得"></a>求CDF需要打表，或者用c++解析解的函数求得</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image8.png"
                      class=""
                >

<h3 id="又假设切比雪夫不等式来优化计算CDF时间：这里把不等式假设为等式，t的限制也不考虑了，CDF-1-P-x"><a href="#又假设切比雪夫不等式来优化计算CDF时间：这里把不等式假设为等式，t的限制也不考虑了，CDF-1-P-x" class="headerlink" title="又假设切比雪夫不等式来优化计算CDF时间：这里把不等式假设为等式，t的限制也不考虑了，CDF &#x3D; 1 - P(x)"></a>又假设切比雪夫不等式来优化计算CDF时间：这里把不等式假设为等式，t的限制也不考虑了，CDF &#x3D; 1 - P(x)</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image9.png"
                      class=""
                >

<h3 id="第三步的深度平均值好算，但是第一步需要的是遮挡物的平均深度不好做：这里直接假设非遮挡物的平均深度为t，这样就可以解出来遮挡物的平均深度了"><a href="#第三步的深度平均值好算，但是第一步需要的是遮挡物的平均深度不好做：这里直接假设非遮挡物的平均深度为t，这样就可以解出来遮挡物的平均深度了" class="headerlink" title="第三步的深度平均值好算，但是第一步需要的是遮挡物的平均深度不好做：这里直接假设非遮挡物的平均深度为t，这样就可以解出来遮挡物的平均深度了"></a>第三步的深度平均值好算，但是第一步需要的是遮挡物的平均深度不好做：这里直接假设非遮挡物的平均深度为t，这样就可以解出来遮挡物的平均深度了</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image10.png"
                      class=""
                >

<h3 id="VSSM的效果"><a href="#VSSM的效果" class="headerlink" title="VSSM的效果"></a>VSSM的效果</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image11.png"
                      class=""
                >

<h2 id="深度图的Mipmap怎么做：Summed-Area-Table-SAT"><a href="#深度图的Mipmap怎么做：Summed-Area-Table-SAT" class="headerlink" title="深度图的Mipmap怎么做：Summed Area Table(SAT)"></a>深度图的Mipmap怎么做：Summed Area Table(SAT)</h2><h3 id="一定范围内求平均或者一定范围内求总和（前缀和算法）"><a href="#一定范围内求平均或者一定范围内求总和（前缀和算法）" class="headerlink" title="一定范围内求平均或者一定范围内求总和（前缀和算法）"></a>一定范围内求平均或者一定范围内求总和（前缀和算法）</h3><h4 id="一维情况：SAT的值为加到当前索引i的和，算3到6的总和直接用SAT-6-SAT-3-就能得到"><a href="#一维情况：SAT的值为加到当前索引i的和，算3到6的总和直接用SAT-6-SAT-3-就能得到" class="headerlink" title="一维情况：SAT的值为加到当前索引i的和，算3到6的总和直接用SAT[6] - SAT[3]就能得到"></a>一维情况：SAT的值为加到当前索引i的和，算3到6的总和直接用SAT[6] - SAT[3]就能得到</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image12.png"
                      class=""
                >

<h4 id="二维情况：SAT表示从左上角加到当前位置的值-做法：横着加一遍，再竖着加一遍"><a href="#二维情况：SAT表示从左上角加到当前位置的值-做法：横着加一遍，再竖着加一遍" class="headerlink" title="二维情况：SAT表示从左上角加到当前位置的值(做法：横着加一遍，再竖着加一遍)"></a>二维情况：SAT表示从左上角加到当前位置的值(做法：横着加一遍，再竖着加一遍)</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image13.png"
                      class=""
                >

<h2 id="Moment-Shadow-mapping"><a href="#Moment-Shadow-mapping" class="headerlink" title="Moment Shadow mapping"></a>Moment Shadow mapping</h2><h3 id="VSSM的问题：比较杂乱的情况下效果还不错，但是简单情况就容易露馅（变白：本来应该有阴影的红色框的阴影却不明显，变黑：本来不该有阴影的地方却变成了阴影）"><a href="#VSSM的问题：比较杂乱的情况下效果还不错，但是简单情况就容易露馅（变白：本来应该有阴影的红色框的阴影却不明显，变黑：本来不该有阴影的地方却变成了阴影）" class="headerlink" title="VSSM的问题：比较杂乱的情况下效果还不错，但是简单情况就容易露馅（变白：本来应该有阴影的红色框的阴影却不明显，变黑：本来不该有阴影的地方却变成了阴影）"></a>VSSM的问题：比较杂乱的情况下效果还不错，但是简单情况就容易露馅（变白：本来应该有阴影的红色框的阴影却不明显，变黑：本来不该有阴影的地方却变成了阴影）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image14.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image15.png"
                      class=""
                >

<h3 id="Moment-Shadow-Mapping解决VSSM分布不准的问题：Moment（矩）-这里可以用高级的矩来描述分布（VSSM等效于只用到了x和x-2，也就是二阶矩）"><a href="#Moment-Shadow-Mapping解决VSSM分布不准的问题：Moment（矩）-这里可以用高级的矩来描述分布（VSSM等效于只用到了x和x-2，也就是二阶矩）" class="headerlink" title="Moment Shadow Mapping解决VSSM分布不准的问题：Moment（矩）,这里可以用高级的矩来描述分布（VSSM等效于只用到了x和x^2，也就是二阶矩）"></a>Moment Shadow Mapping解决VSSM分布不准的问题：Moment（矩）,这里可以用高级的矩来描述分布（VSSM等效于只用到了x和x^2，也就是二阶矩）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image16.png"
                      class=""
                >

<h3 id="理论的来源：4阶矩模拟PCF就挺准了（用一张rgbaHalf的图来储存）"><a href="#理论的来源：4阶矩模拟PCF就挺准了（用一张rgbaHalf的图来储存）" class="headerlink" title="理论的来源：4阶矩模拟PCF就挺准了（用一张rgbaHalf的图来储存）"></a>理论的来源：4阶矩模拟PCF就挺准了（用一张rgbaHalf的图来储存）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image17.png"
                      class=""
                >

<h3 id="Moment-Shadow-Mapping的效果"><a href="#Moment-Shadow-Mapping的效果" class="headerlink" title="Moment Shadow Mapping的效果"></a>Moment Shadow Mapping的效果</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image18.png"
                      class=""
                >

<h3 id="Moment的解法公式较为复杂："><a href="#Moment的解法公式较为复杂：" class="headerlink" title="Moment的解法公式较为复杂："></a>Moment的解法公式较为复杂：</h3><h4 id="MOIT的矩用法"><a href="#MOIT的矩用法" class="headerlink" title="MOIT的矩用法"></a>MOIT的矩用法</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image19.png"
                      class=""
                >

<p>M OIT中的解法</p>
<p><strong>这里先假设bj（bj可以为其它z^j的函数）为z的j次方，先求出q这个向量的值</strong></p>
<p><strong>MOIT这里的bj相当于是还乘上了log(alpha)，貌似这里的矩bj应该是某一块的z平均值</strong></p>
<p><strong>然后解一个一元m&#x2F;2次的方程，解出m&#x2F;2个解zi(不包括z0)</strong></p>
<p><strong>比较zi和z0的大小，得出vl，即v矩阵</strong></p>
<p><strong>再解矩阵的得到向量u</strong></p>
<p><strong>最后把bj*uj求和</strong></p>
<h4 id="MSM中矩的用法"><a href="#MSM中矩的用法" class="headerlink" title="MSM中矩的用法"></a>MSM中矩的用法</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/21/Games202-lecture4/image20.png"
                      class=""
                >

<p>MSM中的解法</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li><a class="link"   href="https://www.bilibili.com/video/BV1YK4y1T7yY?spm_id_from=333.788.videopod.episodes&vd_source=00d16791e62a7a30669fd64792ae22dc&p=4" >GAMES202-高质量实时渲染-Lecture4 Real-time Shadow2<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://momentsingraphics.de/Media/I3D2015/MomentShadowMapping.pdf" >Moment Shadow Mapping<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li><a class="link"   href="https://momentsingraphics.de/Media/I3D2018/Muenstermann2018-MBOIT.pdf" >Moment-Based Order-Independent Transparency<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture6-实时的环境光照2</title>
    <url>/2025/01/23/Games202-lecture6/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image1.png"
                      class=""
                >

<h2 id="环境光的阴影（应该相当于是环境光的遮蔽关系）：工业界从最亮的光源渲染Shadow-map"><a href="#环境光的阴影（应该相当于是环境光的遮蔽关系）：工业界从最亮的光源渲染Shadow-map" class="headerlink" title="环境光的阴影（应该相当于是环境光的遮蔽关系）：工业界从最亮的光源渲染Shadow map?"></a>环境光的阴影（应该相当于是环境光的遮蔽关系）：工业界从最亮的光源渲染Shadow map?</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image2.png"
                      class=""
                >

<h2 id="频率和频域的复习"><a href="#频率和频域的复习" class="headerlink" title="频率和频域的复习"></a>频率和频域的复习</h2><h3 id="傅里叶级数展开（傅里叶变换，Fourier-Transform）"><a href="#傅里叶级数展开（傅里叶变换，Fourier-Transform）" class="headerlink" title="傅里叶级数展开（傅里叶变换，Fourier Transform）"></a>傅里叶级数展开（傅里叶变换，Fourier Transform）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image3.png"
                      class=""
                >

<h2 id="频域空间的内容"><a href="#频域空间的内容" class="headerlink" title="频域空间的内容"></a>频域空间的内容</h2><h3 id="原始情况下"><a href="#原始情况下" class="headerlink" title="原始情况下"></a>原始情况下</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image4.png"
                      class=""
                >

<h3 id="低通滤波后"><a href="#低通滤波后" class="headerlink" title="低通滤波后"></a>低通滤波后</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image5.png"
                      class=""
                >

<h2 id="卷积理论"><a href="#卷积理论" class="headerlink" title="卷积理论"></a>卷积理论</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image6.png"
                      class=""
                >

<h2 id="基函数"><a href="#基函数" class="headerlink" title="基函数"></a>基函数</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image7.png"
                      class=""
                >

<h2 id="球面谐波"><a href="#球面谐波" class="headerlink" title="球面谐波"></a>球面谐波</h2><h3 id="球谐的基函数大致的形状"><a href="#球谐的基函数大致的形状" class="headerlink" title="球谐的基函数大致的形状"></a>球谐的基函数大致的形状</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image8.png"
                      class=""
                >

<h3 id="球谐基函数的系数计算：也叫投影到基函数（在球面上采样对基函数相乘然后积分）"><a href="#球谐基函数的系数计算：也叫投影到基函数（在球面上采样对基函数相乘然后积分）" class="headerlink" title="球谐基函数的系数计算：也叫投影到基函数（在球面上采样对基函数相乘然后积分）"></a>球谐基函数的系数计算：也叫投影到基函数（在球面上采样对基函数相乘然后积分）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image9.png"
                      class=""
                >

<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image10.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image11.png"
                      class=""
                >

<h3 id="做法：投影：把灯光投影到某个基函数需要积分所有的灯光在基函数上的投影然后积分（积分可以用蒙特卡洛解决）反投影：每个系数乘以基函数然后求和"><a href="#做法：投影：把灯光投影到某个基函数需要积分所有的灯光在基函数上的投影然后积分（积分可以用蒙特卡洛解决）反投影：每个系数乘以基函数然后求和" class="headerlink" title="做法：投影：把灯光投影到某个基函数需要积分所有的灯光在基函数上的投影然后积分（积分可以用蒙特卡洛解决）反投影：每个系数乘以基函数然后求和"></a>做法：投影：把灯光投影到某个基函数需要积分所有的灯光在基函数上的投影然后积分（积分可以用蒙特卡洛解决）反投影：每个系数乘以基函数然后求和</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image12.png"
                      class=""
                >

<h2 id="用球谐解决visibility项：PRT的效果（Precomputed-Radiance-Transfer）"><a href="#用球谐解决visibility项：PRT的效果（Precomputed-Radiance-Transfer）" class="headerlink" title="用球谐解决visibility项：PRT的效果（Precomputed Radiance Transfer）"></a>用球谐解决visibility项：PRT的效果（Precomputed Radiance Transfer）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image13.png"
                      class=""
                >

<h3 id="PRT的思想：光照可以发生改变，物体不改变，则light-transport就不会改变。相当于预计算空间中所有点的light-transport，存放到球协函数中（这里应该只能预计算Diffuse的BRDF吧）"><a href="#PRT的思想：光照可以发生改变，物体不改变，则light-transport就不会改变。相当于预计算空间中所有点的light-transport，存放到球协函数中（这里应该只能预计算Diffuse的BRDF吧）" class="headerlink" title="PRT的思想：光照可以发生改变，物体不改变，则light transport就不会改变。相当于预计算空间中所有点的light transport，存放到球协函数中（这里应该只能预计算Diffuse的BRDF吧）"></a>PRT的思想：光照可以发生改变，物体不改变，则light transport就不会改变。相当于预计算空间中所有点的light transport，存放到球协函数中（这里应该只能预计算Diffuse的BRDF吧）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image14.png"
                      class=""
                >

<h3 id="分情况：Diffuse-Case-BRDF-ρ可以看成一个常数，所以可以移出到积分外面"><a href="#分情况：Diffuse-Case-BRDF-ρ可以看成一个常数，所以可以移出到积分外面" class="headerlink" title="分情况：Diffuse Case (BRDF ρ可以看成一个常数，所以可以移出到积分外面)"></a>分情况：Diffuse Case (BRDF ρ可以看成一个常数，所以可以移出到积分外面)</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/23/Games202-lecture6/image15.png"
                      class=""
                >
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>PBR</tag>
        <tag>Environment Lighting</tag>
        <tag>Global Illumination</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture8-全局光照（屏幕空间）</title>
    <url>/2025/01/25/Games202-lecture8/</url>
    <content><![CDATA[<p><strong>大纲</strong></p>
<p>预计把上节课没有讲的LPV和VXGI将完，然后把SSAO和SSDO介绍完</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image1.png"
                      class=""
                >

<p><strong>LPV（Light Propagation Volumes）</strong></p>
<p>LPV最早是在孤岛危机3（”显卡危机”）中被引入的</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image2.png"
                      class=""
                >

<p><strong>关键问题</strong></p>
<p>思考：每个Shading Point能够查询到每个方向来的环境光照，Radiance在传播过程中不会改变</p>
<p>LPV的想法就是把场景体素化为多个voxel，然后预计算每个格子获取的直接Radiance，然后再传播到其它voxel中</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image3.png"
                      class=""
                >

<p><strong>做法的步骤</strong></p>
<ol>
<li><p>生成场景直接的radiance</p>
</li>
<li><p>注入到体素化的voxel中</p>
</li>
<li><p>计算Radiance传播后的Radiance</p>
</li>
<li><p>渲染时查询voxel直接使用</p>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image4.png"
                      class=""
                >

<p><strong>具体一点的步骤</strong></p>
<p><strong>step1: 先生成场景直接的Radiance</strong></p>
<p>可以用RSM加速</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image5.png"
                      class=""
                >

<p><strong>step2:把直接Radiance注入到格子中</strong></p>
<p>场景的体素化可以预计算划分好，把格子包括的虚拟点光源的Radiance储存起来（这里应该会根据法线等使用不同的brdf），格子里面储存的是一个2阶的球谐系数来模拟各个方向的Radiance分布</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image6.png"
                      class=""
                >

<p><strong>step3:在格子中传播Radiance直到收敛（这里一般不考虑visibility，不然太难了）</strong></p>
<p>每次把格子中的radiance往隔壁的6个面中去传播</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image7.png"
                      class=""
                >

<p><strong>step4:用Shading Point所属格子中SH来还原光照渲染，问题<br>（格子粒度大了薄一点的墙壁会漏光，可以用八叉树等来加速）</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image8.png"
                      class=""
                >

<p><strong>VXGI （Voxel Global Illumination）</strong></p>
<p>执行两趟的算法，与RSM比较：VXGI会体素化场景，RSM是表面像素；VXGI在Shading Point用Cone Tracing来追踪体素的Radiance，RSM的Shading Point对每个光源的RSM的像素计算Radiance</p>
<p>VXGI需要体素化这个场景，并把场景用八叉树来管理</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image9.png"
                      class=""
                >

<p><strong>步骤</strong></p>
<p><strong>step1:<br>每个体素记录对应表面的法线分布，还需要记录光源incident的分布，然后再简历树状结构（可能是把低级的voxel记录的值平均一下）</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image10.png"
                      class=""
                >

<p><strong>step2: 用Cone<br>Tracing来查询Radiance，用树状的Voxel来加速（锥形越远会越大，查询的体素Level也需要更高），</strong></p>
<p><strong>对于Glossy表面，只在反射方向发射一个Cone就行了，例子上查4次就可以累加出Radiance了</strong></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image11.png"
                      class=""
                >

<p>对于Diffuse表面，用8个小圆锥查询，然后加起来就好了（闫神说也可以用一个巨大圆锥），缝隙和覆盖问题这里不严格考虑</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image12.png"
                      class=""
                >

<p><strong>VXGI于LPV相比：</strong></p>
<ol>
<li><p>VXGI比LPV慢</p>
</li>
<li><p>VXGI比LPV效果更好一些，因为VXGI是追踪BRDF方向的，而LPV不考虑遮挡让光源传播出来的</p>
</li>
<li><p>都需要体素化，VXGI需要的精度可能更高，而且需要建立层级结构</p>
</li>
</ol>
<p><strong>屏幕空间环境光遮蔽（SSAO）</strong></p>
<p><strong>引入SSAO</strong></p>
<p>ssao最早在Crytek引擎引入</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image13.png"
                      class=""
                >

<p>AO会在物体接触位置生成一些阴影，看起来会更加有立体感（而且AO相对来说好实现）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image14.png"
                      class=""
                >

<p>SSAO是对环境光照的部分信息的近似，所有的信息来源是屏幕空间。SSAO做了两个假设，一是不知道间接光照的来源，二是假设环境光是常数</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image15.png"
                      class=""
                >

<p>SSAO考虑到不同方向对环境光的可见性不一样，并且把所有材质在AO上都假设为Diffuse材质</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image16.png"
                      class=""
                >

<p><strong>SSAO的原理</strong></p>
<p>从下面的图考虑环境光的假设（可能跟BRDF的G项类似，越复杂的地方光线越难进来或者出去）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image17.png"
                      class=""
                >

<p>从渲染方程来考虑SSAO的背后的原理。把可见性拆分出来，积分出来的值相当于Ka，光照部分就相当于常数的Albedo</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image18.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image19.png"
                      class=""
                >

<p>更深的理解积分拆分后，对前面的积分相当于是在积分域内对f(x)求平均</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image20.png"
                      class=""
                >

<p>更深的理解，为啥篮筐位置的下面会有个cosθ。因为光照方程可以看成对cosθdwi积分，而不是对dwi积分</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image21.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image22.png"
                      class=""
                >

<p>因为假设了环境光为常数，BRDF为常数，可以拿到积分外面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image23.png"
                      class=""
                >

<p><strong>SSAO的做法</strong></p>
<p>只考虑着色点附近半径为R的半球范围内的遮挡情况，这个R的选取可能会造成一些trick</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image24.png"
                      class=""
                >

<p>SSAO进一步简化，用已经分布好的点来采样，然后算一个在物体外部的点数量比例。但是内外也不好算，再进一步假设用点深度比ShadingPoint深度近的来当作在物体外的点（会出现第二个点那种误判，不过出现概率不过所以没关系）。这里没有画出来，但是实际使用的法线方向的半球来采样的。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image25.png"
                      class=""
                >

<p><strong>SSAO的问题：</strong></p>
<p>没有考虑空间连续性，在前后没有连续的石凳附近也出现了AO。SSAO的理论本来是用R半径限制的，但是为了实现更快又假设用深度来比较了，这里相当于丢了深度方向的距离R这个条件（相当于在深度图上只考虑了2维的R半径）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image26.png"
                      class=""
                >

<p>可以用HBAO来解决（会真正考虑一个半球范围）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image27.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/25/Games202-lecture8/image28.png"
                      class=""
                >
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Environment Lighting</tag>
        <tag>Global Illumination</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture9-全局光照（屏幕空间）</title>
    <url>/2025/01/26/Games202-lecture9/</url>
    <content><![CDATA[<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>这一节课主要是把”屏幕空间的方向性遮挡”和”屏幕空间反射”讲完。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image1.png"
                      class=""
                >

<h2 id="屏幕空间的方向性遮挡（Screen-Space-Directional-Occlusion）"><a href="#屏幕空间的方向性遮挡（Screen-Space-Directional-Occlusion）" class="headerlink" title="屏幕空间的方向性遮挡（Screen Space Directional Occlusion）"></a>屏幕空间的方向性遮挡（Screen Space Directional Occlusion）</h2><h3 id="回忆一下SSAO"><a href="#回忆一下SSAO" class="headerlink" title="回忆一下SSAO"></a>回忆一下SSAO</h3><p>假设了深度深浅来代替是否被环境光遮挡</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image2.png"
                      class=""
                >

<h3 id="引入SSDO"><a href="#引入SSDO" class="headerlink" title="引入SSDO"></a>引入SSDO</h3><p>SSDO是SSAO的加强版，类似RSM，被点亮的地方会作为次级光源照亮其它区域</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image3.png"
                      class=""
                >

<p>SSDO的间接光来自于相机（屏幕），RSM是来自于Shadow Map</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image4.png"
                      class=""
                >

<h3 id="SSDO的做法"><a href="#SSDO的做法" class="headerlink" title="SSDO的做法"></a>SSDO的做法</h3><p>类似于Path Tracing，在着色点随机发射一条射线，打到遮挡物就是反射过来间接光，没有打到遮挡物就是用直接光照亮。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image5.png"
                      class=""
                >

<p>对比SSAO和SSDO，SSAO假设环境光来自无限远，SSDO假设间接光来自近处（判断遮挡会设置一个距离的阈值）。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image6.png"
                      class=""
                >

<p>SSDO的数学原理，把光照分为两种情况进行计算：对非遮挡（V&#x3D;1）情况计算直接光照，对遮挡物体（V&#x3D;0）计算间接光照</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image7.png"
                      class=""
                >

<p>在Shading Point考虑法线方向的半球，与SSAO一样用从相机的深度来判断哪些点被遮挡（ABD点）和哪一些点可见（C点），然后用不可见点（对应在屏幕上的点，即屏幕表面的点）计算间接光照，用可见点（也是对应屏幕上的点）计算直接光照，然后把光照累加起来就行了。</p>
<p>当然，也会出现与SSAO相同的问题，即从相机的深度判断容易出现误判（第三张图的A点本来应该被P点可见，B点不应该被P可见），最正确当然是从点P渲染一张ShadowMap来判断，但是这样带来的开销太大了。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image8.png"
                      class=""
                >

<h3 id="SSDO的问题"><a href="#SSDO的问题" class="headerlink" title="SSDO的问题"></a>SSDO的问题</h3><p>GI只存在于短距离，可见性的考虑不准，只能解决在屏幕范围内的GI</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image9.png"
                      class=""
                >

<h2 id="屏幕空间的反射（Screen-Space-Reflection）"><a href="#屏幕空间的反射（Screen-Space-Reflection）" class="headerlink" title="屏幕空间的反射（Screen Space Reflection）"></a>屏幕空间的反射（Screen Space Reflection）</h2><p>SSR是解决GI的一种方式（主要是解决间接光镜面反射的问题），可以理解为屏幕空间的光线追踪，但是不是与几何物体求交</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image10.png"
                      class=""
                >

<p>观察到现实中镜面反射大部分内容来自于已经在屏幕中存在的内容，这样只需要考虑对屏幕空间的内容来做反射，这样相对于光线追踪可以节省计算量</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image11.png"
                      class=""
                >

<p>SSR也可以做Glossy的反射，但是这样可能反射的光线需要多根，计算量变大了。所以一般SSR只用来做镜面反射，这样高端的移动设备也能开启SSR。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image12.png"
                      class=""
                >

<h3 id="SSR的做法"><a href="#SSR的做法" class="headerlink" title="SSR的做法"></a>SSR的做法</h3><p>大致的思路，从ShadingPoint发出一根光线，沿着光线方向与屏幕像素求交，最后用交点的颜色作为反射的颜色</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image13.png"
                      class=""
                >

<p>需要延迟渲染的内容，法线、深度以及直接着色后的颜色Buffer</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image14.png"
                      class=""
                >

<p>光线步进的做法，有一个着色点和一个反射方向，沿着反射方向每次增加一定距离，直到这个点超过了深度图上的值（用深度图作为可见性判断，如果没有在屏幕上的信息可能会计算错），用对应深度图的交点作为实际反射的交点。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image15.png"
                      class=""
                >

<h3 id="加速RayMarch"><a href="#加速RayMarch" class="headerlink" title="加速RayMarch"></a>加速RayMarch</h3><p>步长太长可能不准，太短又可能要进行很多次，所以要用动态决定步长来加快RayMarch的速度。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image16.png"
                      class=""
                >

<p>预计算，把Depth做Mipmap，用最小的深度作为下一层的深度值。这个相当于是Hierarchy Z的图（HIZ需要的数据）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image17.png"
                      class=""
                >

<p>原理：如果光线与高层（粗粒度）的值不相交，则一定不会与更细粒度的值相交。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image18.png"
                      class=""
                >

<p>伪代码，如果没有交点就增加层级，如果有交点后就减少层级求交</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image19.png"
                      class=""
                >

<p>示例：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image20.gif"
                      class=""
                >

<p>有一个问题：当起点不是2幂次时，mipmap不能查询，所以要么先步进到2的幂次，要么用层间的混合值</p>
<h3 id="SSR的着色"><a href="#SSR的着色" class="headerlink" title="SSR的着色"></a>SSR的着色</h3><p>用反射到的ShadingPoint颜色作为可以出射的Radiance，然后积分起来（镜面反射一般只考虑反射方向）</p>
<p>思考：</p>
<p>问题1：没有距离衰减，因为不是从光源反着采样积分</p>
<p>问题2：次级光源的可见性是考虑了的，因为是Tacing出来的，肯定不会有遮挡</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image21.png"
                      class=""
                >

<h3 id="SSR的现象"><a href="#SSR的现象" class="headerlink" title="SSR的现象"></a>SSR的现象</h3><p>我这里认为以下现象一般都不会在游戏里面看到，因为游戏里面一般SSR都是用来做镜面反射的，一般来说都只Trace一根光线，而且应该都是反射方向（非BRDF重要性采样，当然如果TAA下应该用采样更接近正确效果）</p>
<p>现象1：如果准确考虑BRDF，那么specular反射是锐利的，diffude反射是模糊的</p>
<p>现象2：如果准确考虑BRDF，越近越清楚，越远越模糊</p>
<p>现象3：如果准确考虑了BRDF，法线分布是椭圆，那么会出现雨天车灯长条的效果（各向同性）</p>
<p>现象4：每个像素的粗糙度和法线不一样，粒度是像素</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image22.png"
                      class=""
                >

<h3 id="SSR的提高"><a href="#SSR的提高" class="headerlink" title="SSR的提高"></a>SSR的提高</h3><p>可以用BRDF（NDF）来做重要性采样</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image23.png"
                      class=""
                >

<p>复用交点，可以增加Sample数量：比如说每个ShadingPoint出射一个光线，但是ShadingPoint可以用隔壁ShadingPoint的交点的信息加进来，权重用BRDF快速算出来。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image24.png"
                      class=""
                >

<p>可以Filter 直接光Shading的Color值(但是深度怎么Filter)，然后用一次采样来代替多次采样</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image25.png"
                      class=""
                >

<h3 id="SSR总结"><a href="#SSR总结" class="headerlink" title="SSR总结"></a>SSR总结</h3><p>好处：性能好，效果好，遮挡效果准确</p>
<p>坏处：diffuse的情况效率低，缺少不在屏幕的信息</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/26/Games202-lecture9/image26.png"
                      class=""
                >

<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote>
<p><a class="link"   href="https://www.bilibili.com/video/BV1YK4y1T7yY?spm_id_from=333.788.videopod.episodes&vd_source=00d16791e62a7a30669fd64792ae22dc&p=9" >Games202-Lecture9-实时全局光照(屏幕空间)<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Environment Lighting</tag>
        <tag>Global Illumination</tag>
      </tags>
  </entry>
  <entry>
    <title>记录Hexo与Github搭建个人博客</title>
    <url>/2025/01/11/LearnUseHexo/</url>
    <content><![CDATA[<h2 id="Hexo-相关命令指南"><a href="#Hexo-相关命令指南" class="headerlink" title="Hexo 相关命令指南"></a>Hexo 相关命令指南</h2><ul>
<li>本地打包：<code>hexo g</code></li>
<li>本地启动：<code>hexo s</code></li>
<li>本地打包并推送到 Git：<code>hexo g -d</code></li>
<li>创建新文章：<code>hexo new post 测试文章</code></li>
<li>创建自定义页：<code>hexo new page 新页</code></li>
<li>清除缓存：<code>hexo clean</code></li>
</ul>
<h2 id="出现的一点问题"><a href="#出现的一点问题" class="headerlink" title="出现的一点问题"></a>出现的一点问题</h2><h3 id="1-统计量不显示"><a href="#1-统计量不显示" class="headerlink" title="1.统计量不显示"></a>1.统计量不显示</h3><p>统计阅读量的这里需要添加server_url，貌似是只有中国地区需要</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image1.png"
                      class=""
                >
<p>server_url添加的是这个REST API</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image2.png"
                      class=""
                >
<h3 id="2-图片在本地MarkDown显示但是在Hexo上不显示"><a href="#2-图片在本地MarkDown显示但是在Hexo上不显示" class="headerlink" title="2.图片在本地MarkDown显示但是在Hexo上不显示"></a>2.图片在本地MarkDown显示但是在Hexo上不显示</h3><p>需要安装hexo-renderer-marked来解决</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure></div>
<h3 id="3-图片没有打包到Public中"><a href="#3-图片没有打包到Public中" class="headerlink" title="3. 图片没有打包到Public中"></a>3. 图片没有打包到Public中</h3><p>使用<code>hexo clean</code>清除缓存，然后再重新生成<code>hexo g</code></p>
<h3 id="4-域名文件CNAME重新生成会被删除"><a href="#4-域名文件CNAME重新生成会被删除" class="headerlink" title="4. 域名文件CNAME重新生成会被删除"></a>4. 域名文件CNAME重新生成会被删除</h3><p>CNAME文件是用来把新域名重载到username.github.io的，因为hexo上传会重新生成public目录，CNAME文件被删除会导致访问报错：<code>404 There is not a GitHub Pages site here</code><br>解决方式是把CNAME文件放到hexo-blog&#x2F;source目录，这样重新生成public目录就会带着CNAME文件了</p>
<h3 id="5-本地打包并推送到git失败"><a href="#5-本地打包并推送到git失败" class="headerlink" title="5. 本地打包并推送到git失败"></a>5. 本地打包并推送到git失败</h3><p>使用<code>hexo g -d</code>指令失败，提示无法连接到服务器。这个我多试几次就好了（运气不好可能十几次），</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image3.png"
                      class=""
                >
<p>另一个办法应该是可以在Public空目录下拉一个git，然后再用<code>hexo g</code>重新生成，最后自己手动push到git仓库</p>
<h3 id="6-替换redefine主题之后hexo-clean-hexo-g会报错"><a href="#6-替换redefine主题之后hexo-clean-hexo-g会报错" class="headerlink" title="6. 替换redefine主题之后hexo clean|hexo g会报错"></a>6. 替换redefine主题之后hexo clean|hexo g会报错</h3><p>当使用redefine主题重新生成的时候会报错：<code>ERROR Asset render failed</code></p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">ERROR Asset render failed: css/common/markdown.css</span><br><span class="line"><span class="function">CssSyntaxError: <span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Daron</span>\<span class="title">hexo</span>-<span class="title">blog</span>\<span class="title">themes</span>\<span class="title">redefine</span>\<span class="title">source</span>\<span class="title">css</span>\<span class="title">common</span>\<span class="title">markdown.styl</span>:131:1: <span class="title">Unknown</span> <span class="title">word</span> <span class="title">at</span> <span class="title">Input.error</span> (<span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Daron</span>\<span class="title">hexo</span>-<span class="title">blog</span>\<span class="title">node_modules</span>\<span class="title">postcss</span>\<span class="title">lib</span>\<span class="title">input.js</span>:128:16)</span></span><br><span class="line"><span class="function">....</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ERROR</span> <span class="title">Asset</span> <span class="title">render</span> <span class="title">failed</span>: <span class="title">css</span>/<span class="title">layout</span>/<span class="title">category</span>-<span class="title">list.css</span> <span class="title">CssSyntaxError</span>: <span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Daron</span>\<span class="title">hexo</span>-<span class="title">blog</span>\<span class="title">themes</span>\<span class="title">redefine</span>\<span class="title">source</span>\<span class="title">css</span>\<span class="title">layout</span>\<span class="title">category</span>-<span class="title">list.styl</span>:23:1: <span class="title">Unknown</span> <span class="title">word</span> <span class="title">at</span> <span class="title">Input.error</span> (<span class="title">C</span>:\<span class="title">Users</span>\<span class="title">Daron</span>\<span class="title">hexo</span>-<span class="title">blog</span>\<span class="title">node_modules</span>\<span class="title">postcss</span>\<span class="title">lib</span>\<span class="title">input.js</span>:128:16)</span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image4.png"
                      class="" title="报错样例"
                >
<p>经过一通排查，发现是markdown.styl和category-list.styl文件中用的<code>+redefine-tablet()</code>和<code>+redefine-mobile()</code>这两个Mixin未定义导致的。Mixin相当于是函数，用’+’来调用。通过全局搜索发现函数的定义在basic.styl中，解决方法是引入basic.styl这个头文件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image5.png"
                      class="" title="解决方法"
                >


<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image6.png"
                      class="" title="解决方法"
                >

<h3 id="7-随笔页面第一次进入不显示评论，需要刷新才显示（redefine主题）"><a href="#7-随笔页面第一次进入不显示评论，需要刷新才显示（redefine主题）" class="headerlink" title="7.随笔页面第一次进入不显示评论，需要刷新才显示（redefine主题）"></a>7.随笔页面第一次进入不显示评论，需要刷新才显示（redefine主题）</h3><p>网上找了很多解决方案都不能用，发现把主题配置中把<code>single_page</code>改成<code>false</code>就可以了。</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Whether to enable single page experience (using swup). See https://swup.js.org/. similar to pjax</span></span><br><span class="line"><span class="attr">single_page:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></div>

<p>后面发现把<code>single_page</code>改成<code>false</code>后加载确实变慢了。为了速度，又倒腾了半天，终于找到更好的解决办法，在<code>swup.ejs</code>配置中添加忽略<code>/essays</code>页面</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/11/LearnUseHexo/image7.png"
                      class="" title="忽略essays页面"
                >
<p>oh, yes!</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a class="link"   href="https://blog.csdn.net/yaorongke/article/details/119089190" >GitHub Pages + Hexo搭建个人博客网站，史上最全教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://github.com/qiubaiying/qiubaiying.github.io/wiki/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B" >博客搭建详细教程<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://arcsin2.cloud/2023/02/23/Hexo-%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" >Hexo博客无法显示图片解决方法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://blog.csdn.net/qq_43000128/article/details/134348650" >解决hexo图片无法显示问题<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>UE5 渲染源码学习 - 添加描边后处理 Shader</title>
    <url>/2025/03/10/UE5AddPostShader/</url>
    <content><![CDATA[<h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>纯 HTML 实现滑动对比</title>
    <style>
        .comparison-container {
            position: relative;
            width: 600px;
            height: 400px;
            overflow: hidden;
            user-select: none; /* 防止选中文字 */
        }
        .comparison-container img {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .comparison-top {
            clip-path: inset(0 50% 0 0); /* 默认遮挡右侧 50% */
            transition: clip-path 0.1s ease-out; /* 平滑过渡 */
            z-index: 2;
        }
        input[type="range"] {
            position: absolute;
            width: 100%;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            appearance: none;
            background: none;
            pointer-events: all;
            z-index: 3;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 10px;
            height: 400px;
            background: rgba(255, 255, 255, 0.8);
            cursor: ew-resize;
            pointer-events: all;
        }
        input[type="range"]::-moz-range-thumb {
            width: 10px;
            height: 400px;
            background: rgba(255, 255, 255, 0.8);
            cursor: ew-resize;
        }
    </style>
</head>
<body>

<div class="comparison-container">
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/10/UE5AddPostShader/image1.png"
                       alt="Before"
                >
    <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/10/UE5AddPostShader/image2.png"
                       alt="After" class="comparison-top"
                >
    <input type="range" min="0" max="100" value="50" 
        oninput="document.querySelector('.comparison-top').style.clipPath = `inset(0 ${(100 - this.value)}% 0 0)`">
</div>

</body>
</html>

<h2 id="添加描边-Shader：EdgePsShaders-usf"><a href="#添加描边-Shader：EdgePsShaders-usf" class="headerlink" title="添加描边 Shader：EdgePsShaders.usf"></a>添加描边 Shader：<code>EdgePsShaders.usf</code></h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Common.ush&quot;</span></span></span><br><span class="line"></span><br><span class="line">Texture2D SceneColorTexture;</span><br><span class="line">SamplerState SceneColorSampler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainPS</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    noperspective float4 UVAndScreenPos : TEXCOORD0,</span></span></span><br><span class="line"><span class="params"><span class="function">    float4 SvPosition : SV_POSITION,</span></span></span><br><span class="line"><span class="params"><span class="function">    out float4 OutColor : SV_Target0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    float2 UV = UVAndScreenPos.xy;</span><br><span class="line">    float3 FinalColor = <span class="built_in">float3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> edgeSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = -edgeSize; x&lt;=edgeSize; ++x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y = -edgeSize; y &lt;= edgeSize; ++y)</span><br><span class="line">        &#123;</span><br><span class="line">            float2 SampleUV = UV + (<span class="built_in">float2</span>(x,y) * View.BufferSizeAndInvSize.zw);</span><br><span class="line">            float3 SampleColor = <span class="built_in">Texture2DSample</span>(SceneColorTexture, SceneColorSampler, SampleUV).rgb;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                FinalColor += (<span class="number">8</span> * SampleColor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                FinalColor += (<span class="number">-1</span> * SampleColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FinalColor = <span class="built_in">dot</span>(FinalColor, <span class="built_in">float3</span>(<span class="number">0.299</span>, <span class="number">0.587</span>, <span class="number">0.114</span>));</span><br><span class="line">    OutColor = <span class="built_in">float4</span>(FinalColor, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/10/UE5AddPostShader/image3.png"
                      class=""
                >

<h2 id="添加-Renderer-以及-Shader-声明"><a href="#添加-Renderer-以及-Shader-声明" class="headerlink" title="添加 Renderer 以及 Shader 声明"></a>添加 Renderer 以及 Shader 声明</h2><h3 id="DrawEdgePsRendering-h"><a href="#DrawEdgePsRendering-h" class="headerlink" title="DrawEdgePsRendering.h"></a><code>DrawEdgePsRendering.h</code></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RenderGraphFwd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/World.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GlobalShader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PipelineStateCache.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RHIStaticStates.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SceneUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../SceneRendering.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SceneInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderParameterUtils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderEdgePs</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, FRDGTextureRef InputColorTexture, FRDGTextureRef ViewTexture)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="DrawEdgePsRendering-cpp"><a href="#DrawEdgePsRendering-cpp" class="headerlink" title="DrawEdgePsRendering.cpp"></a><code>DrawEdgePsRendering.cpp</code></h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DrawEdgePsRendering.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GlobalShader.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderParameterStruct.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/World.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PipelineStateCache.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RHIStaticStates.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SceneUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SceneInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ShaderParameterUtils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../SceneRendering.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../Public/ScreenPass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FEdgePsPS</span> : <span class="keyword">public</span> FGlobalShader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DECLARE_SHADER_TYPE</span>(FEdgePsPS, Global);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SHADER_USE_PARAMETER_STRUCT</span>(FEdgePsPS, FGlobalShader);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BEGIN_SHADER_PARAMETER_STRUCT</span>(FParameters,)</span><br><span class="line">        <span class="built_in">SHADER_PARAMETER_STRUCT_REF</span>(FViewUniformShaderParameters, View)</span><br><span class="line">        <span class="built_in">SHADER_PARAMETER_RDG_TEXTURE</span>(Texture2D, SceneColorTexture)</span><br><span class="line">        <span class="built_in">SHADER_PARAMETER_SAMPLER</span>(SamplerState, SceneColorSampler)</span><br><span class="line">        <span class="built_in">RENDER_TARGET_BINDING_SLOTS</span>()</span><br><span class="line">    <span class="built_in">END_SHADER_PARAMETER_STRUCT</span>()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_SHADER_TYPE</span>(, FEdgePsPS, <span class="built_in">TEXT</span>(<span class="string">&quot;/Engine/Private/DrawEdge/EdgePsShaders.usf&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;MainPS&quot;</span>), SF_Pixel)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderEdgePs</span><span class="params">(FRDGBuilder&amp; GraphBuilder, <span class="type">const</span> FViewInfo&amp; View, FRDGTextureRef InputColorTexture, FRDGTextureRef ViewFamilyTexture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FRDGTextureRef CopiedViewFamilyTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(ViewFamilyTexture-&gt;Desc, <span class="built_in">TEXT</span>(<span class="string">&quot;CopiedViewFamilyTexture&quot;</span>));</span><br><span class="line">    <span class="built_in">AddCopyTexturePass</span>(GraphBuilder, ViewFamilyTexture, CopiedViewFamilyTexture);</span><br><span class="line"></span><br><span class="line">    <span class="function">TShaderMapRef&lt;FEdgePsPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line">    FEdgePsPS::FParameters* PassParameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FEdgePsPS::FParameters&gt;();</span><br><span class="line">    PassParameters-&gt;View = View.ViewUniformBuffer;</span><br><span class="line">    PassParameters-&gt;SceneColorSampler = TStaticSamplerState&lt;SF_Point, AM_Clamp, AM_Clamp, AM_Clamp&gt;::<span class="built_in">GetRHI</span>();</span><br><span class="line">    PassParameters-&gt;SceneColorTexture = CopiedViewFamilyTexture;</span><br><span class="line">    PassParameters-&gt;RenderTargets[<span class="number">0</span>] = <span class="built_in">FRenderTargetBinding</span>(ViewFamilyTexture, ERenderTargetLoadAction::ENoAction);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AddDrawScreenPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;Edge Pass&quot;</span>), View,</span><br><span class="line">                      <span class="built_in">FScreenPassTextureViewport</span>(ViewFamilyTexture),</span><br><span class="line">                      <span class="built_in">FScreenPassTextureViewport</span>(ViewFamilyTexture),</span><br><span class="line">                      PixelShader, PassParameters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/10/UE5AddPostShader/image4.png"
                      class=""
                >

<h2 id="在延迟渲染管线的最后调用描边渲染Pass"><a href="#在延迟渲染管线的最后调用描边渲染Pass" class="headerlink" title="在延迟渲染管线的最后调用描边渲染Pass"></a>在延迟渲染管线的最后调用描边渲染Pass</h2><p>在 <code>DeferredShadingSceneRenderer.cpp</code> 的 <code>Render()</code> 函数中添加代码：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ViewFamily.bResolveScene &amp;&amp; ViewFamilyTexture)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; Views.<span class="built_in">Num</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> FViewInfo&amp; View = Views[i];</span><br><span class="line">        <span class="built_in">RenderEdgePs</span>(GraphBuilder, View, <span class="literal">nullptr</span>, ViewFamilyTexture);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/03/10/UE5AddPostShader/image5.png"
                      class=""
                >

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote>
<p><a class="link"   href="https://www.bilibili.com/video/BV1au4m1A7W9/?spm_id_from=333.1391.0.0&vd_source=00d16791e62a7a30669fd64792ae22dc" >7 UE5.1 修改引擎源码 新增屏幕特效<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>UE Source</category>
        <category>UE5 Source</category>
      </categories>
      <tags>
        <tag>UE</tag>
        <tag>UE5</tag>
        <tag>UE Source</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-lecture7-全局光照3</title>
    <url>/2025/01/24/Games202-lecture7/</url>
    <content><![CDATA[<h2 id="内容大纲"><a href="#内容大纲" class="headerlink" title="内容大纲"></a>内容大纲</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image1.png"
                      class=""
                >

<h2 id="上节课PRT相关"><a href="#上节课PRT相关" class="headerlink" title="上节课PRT相关"></a>上节课PRT相关</h2><h3 id="PRT主要内容是分布预计算Lighting和Light-Transport"><a href="#PRT主要内容是分布预计算Lighting和Light-Transport" class="headerlink" title="PRT主要内容是分布预计算Lighting和Light Transport"></a>PRT主要内容是分布预计算Lighting和Light Transport</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image2.png"
                      class=""
                >

<h3 id="2维的函数可以投影到球面谐波上"><a href="#2维的函数可以投影到球面谐波上" class="headerlink" title="2维的函数可以投影到球面谐波上"></a>2维的函数可以投影到球面谐波上</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image3.png"
                      class=""
                >

<h3 id="PRT思想-Diffuse-Case"><a href="#PRT思想-Diffuse-Case" class="headerlink" title="PRT思想-Diffuse Case"></a>PRT思想-Diffuse Case</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image4.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image5.png"
                      class=""
                >

<h3 id="上节课推导公式"><a href="#上节课推导公式" class="headerlink" title="上节课推导公式"></a>上节课推导公式</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image6.png"
                      class=""
                >

<h3 id="PRT-Glossy-Case，Light-Transport因为BRDF会变成入射角i和出射角o的函数（用矩阵表示貌似是把i和o统一成一个了）"><a href="#PRT-Glossy-Case，Light-Transport因为BRDF会变成入射角i和出射角o的函数（用矩阵表示貌似是把i和o统一成一个了）" class="headerlink" title="PRT-Glossy Case，Light Transport因为BRDF会变成入射角i和出射角o的函数（用矩阵表示貌似是把i和o统一成一个了）"></a>PRT-Glossy Case，Light Transport因为BRDF会变成入射角i和出射角o的函数（用矩阵表示貌似是把i和o统一成一个了）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image7.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image8.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image9.png"
                      class=""
                >

<h3 id="Interraflections-And-Caustics-内部Bounds多次的PRT预计算怎么理解-就是把L和E之间的给预计算起来就行"><a href="#Interraflections-And-Caustics-内部Bounds多次的PRT预计算怎么理解-就是把L和E之间的给预计算起来就行" class="headerlink" title="Interraflections And Caustics: 内部Bounds多次的PRT预计算怎么理解(就是把L和E之间的给预计算起来就行)"></a>Interraflections And Caustics: 内部Bounds多次的PRT预计算怎么理解(就是把L和E之间的给预计算起来就行)</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image10.png"
                      class=""
                >

<h3 id="貌似PRT结果是储存到Light-Map中（闫令琪说不是存储到Light-Map）？相当于用球谐的基函数作为光照来渲染，然后储存到贴图中"><a href="#貌似PRT结果是储存到Light-Map中（闫令琪说不是存储到Light-Map）？相当于用球谐的基函数作为光照来渲染，然后储存到贴图中" class="headerlink" title="貌似PRT结果是储存到Light Map中（闫令琪说不是存储到Light Map）？相当于用球谐的基函数作为光照来渲染，然后储存到贴图中"></a>貌似PRT结果是储存到Light Map中（闫令琪说不是存储到Light Map）？相当于用球谐的基函数作为光照来渲染，然后储存到贴图中</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image11.png"
                      class=""
                >

<h2 id="各种基函数"><a href="#各种基函数" class="headerlink" title="各种基函数"></a>各种基函数</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image12.png"
                      class=""
                >
<h3 id="小波基函数（Wavelet）-小波基函数的系数大部分会接近零，压缩把接近0的系数都去除"><a href="#小波基函数（Wavelet）-小波基函数的系数大部分会接近零，压缩把接近0的系数都去除" class="headerlink" title="小波基函数（Wavelet）:小波基函数的系数大部分会接近零，压缩把接近0的系数都去除"></a>小波基函数（Wavelet）:小波基函数的系数大部分会接近零，压缩把接近0的系数都去除</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image13.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image14.png"
                      class=""
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image15.png"
                      class=""
                >
<h3 id="小波基函数可以保留高频信息，但是不支持旋转"><a href="#小波基函数可以保留高频信息，但是不支持旋转" class="headerlink" title="小波基函数可以保留高频信息，但是不支持旋转"></a>小波基函数可以保留高频信息，但是不支持旋转</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image16.png"
                      class=""
                >
<h2 id="Reflection-Shadow-Maps-RSM-为了解决One-Bounce间接光照。"><a href="#Reflection-Shadow-Maps-RSM-为了解决One-Bounce间接光照。" class="headerlink" title="Reflection Shadow Maps(RSM): 为了解决One Bounce间接光照。"></a>Reflection Shadow Maps(RSM): 为了解决One Bounce间接光照。</h2><h3 id="介绍：用直接光照亮的patch作为次级光源照亮其它着色点像素两个问题"><a href="#介绍：用直接光照亮的patch作为次级光源照亮其它着色点像素两个问题" class="headerlink" title="介绍：用直接光照亮的patch作为次级光源照亮其它着色点像素两个问题"></a>介绍：用直接光照亮的patch作为次级光源照亮其它着色点像素两个问题</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image17.png"
                      class=""
                >
<h3 id="RSM解决上述两个问题，Q1刚好就可以用Shadow-Map解决"><a href="#RSM解决上述两个问题，Q1刚好就可以用Shadow-Map解决" class="headerlink" title="RSM解决上述两个问题，Q1刚好就可以用Shadow Map解决"></a>RSM解决上述两个问题，Q1刚好就可以用Shadow Map解决</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image18.png"
                      class=""
                >
<h3 id="RSM理论："><a href="#RSM理论：" class="headerlink" title="RSM理论："></a>RSM理论：</h3><h4 id="光源的一些概念：Intensity-Flux-Power-per-Solid-Angle-、Irradiance-Power-per-Area-、Radiance-Power-per-Solid-Andle-per-Area"><a href="#光源的一些概念：Intensity-Flux-Power-per-Solid-Angle-、Irradiance-Power-per-Area-、Radiance-Power-per-Solid-Andle-per-Area" class="headerlink" title="光源的一些概念：Intensity(Flux&#x3D;Power per Solid Angle)、Irradiance(Power per Area)、Radiance(Power per Solid Andle per Area)"></a>光源的一些概念：Intensity(Flux&#x3D;Power per Solid Angle)、Irradiance(Power per Area)、Radiance(Power per Solid Andle per Area)</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image19.png"
                      class=""
                >
<h4 id="回顾q对p的贡献可以用变量替换"><a href="#回顾q对p的贡献可以用变量替换" class="headerlink" title="回顾q对p的贡献可以用变量替换"></a>回顾q对p的贡献可以用变量替换</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image20.png"
                      class=""
                >
<h4 id="替换积分因子后的光源方程：分子是法线和距离的点乘（因为距离没有归一化，所以分子写的是4次方）"><a href="#替换积分因子后的光源方程：分子是法线和距离的点乘（因为距离没有归一化，所以分子写的是4次方）" class="headerlink" title="替换积分因子后的光源方程：分子是法线和距离的点乘（因为距离没有归一化，所以分子写的是4次方）"></a>替换积分因子后的光源方程：分子是法线和距离的点乘（因为距离没有归一化，所以分子写的是4次方）</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image21.png"
                      class=""
                >
<h4 id="贡献的参数：可见性不考虑，考虑方向（方向在Ep计算中已经考虑了）和距离"><a href="#贡献的参数：可见性不考虑，考虑方向（方向在Ep计算中已经考虑了）和距离" class="headerlink" title="贡献的参数：可见性不考虑，考虑方向（方向在Ep计算中已经考虑了）和距离"></a>贡献的参数：可见性不考虑，考虑方向（方向在Ep计算中已经考虑了）和距离</h4><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image22.png"
                      class=""
                >
<h3 id="加速：也可以用某些重要性采样来减少采样次数"><a href="#加速：也可以用某些重要性采样来减少采样次数" class="headerlink" title="加速：也可以用某些重要性采样来减少采样次数"></a>加速：也可以用某些重要性采样来减少采样次数</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image23.png"
                      class=""
                >
<h3 id="应用方向：游戏中的手电筒应用特别好，直接照亮的范围小（Shadow-map小）"><a href="#应用方向：游戏中的手电筒应用特别好，直接照亮的范围小（Shadow-map小）" class="headerlink" title="应用方向：游戏中的手电筒应用特别好，直接照亮的范围小（Shadow map小）"></a>应用方向：游戏中的手电筒应用特别好，直接照亮的范围小（Shadow map小）</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image24.png"
                      class=""
                >
<h3 id="做法：光源做shadow-map，不过还要储存flux信息，有点类似GBuffer了"><a href="#做法：光源做shadow-map，不过还要储存flux信息，有点类似GBuffer了" class="headerlink" title="做法：光源做shadow map，不过还要储存flux信息，有点类似GBuffer了"></a>做法：光源做shadow map，不过还要储存flux信息，有点类似GBuffer了</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image25.png"
                      class=""
                >
<h3 id="优缺点总结："><a href="#优缺点总结：" class="headerlink" title="优缺点总结："></a>优缺点总结：</h3><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2025/01/24/Games202-lecture7/image26.png"
                      class=""
                >]]></content>
      <categories>
        <category>Computer Graphics</category>
        <category>Games 202</category>
      </categories>
      <tags>
        <tag>Environment Lighting</tag>
        <tag>Global Illumination</tag>
      </tags>
  </entry>
</search>
